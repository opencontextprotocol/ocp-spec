#!/usr/bin/env python3
"""
OCP CLI - Command line interface for Open Context Protocol

A standalone CLI tool for context management, API testing, registry operations,
and validation. Focused on developer workflow support.

Usage:
    ocp context create [--user USER] [--type TYPE] [--goal GOAL]
    ocp context show [--format json|yaml]
    ocp call METHOD URL [--context CONTEXT_ID] [--data DATA] [--auth AUTH]
    ocp validate context FILE
    ocp test api URL [--spec SPEC_URL] [--auth AUTH]
    ocp registry list [--category CATEGORY] [--status STATUS]
    ocp registry search QUERY [--page PAGE] [--per-page COUNT]
    ocp registry get NAME
    ocp registry register FILE
    ocp registry validate OPENAPI_URL [--base-url BASE_URL]
    ocp registry categories
    ocp registry stats
    ocp --version
    ocp --help

Examples:
    # Create new context
    ocp context create --user alice --type ide_copilot --goal "debug tests"

    # Make OCP-enabled API call
    ocp call GET https://api.github.com/user --auth "token ghp_xxx"

    # Test API with OCP context
    ocp test api https://api.github.com --spec https://api.github.com/rest/openapi.json

    # Search for APIs in registry
    ocp registry search github

    # Get details about a specific API
    ocp registry get github

    # Register new API from JSON file
    ocp registry register my-api.json

    # Validate context file
    ocp validate context my-context.json
"""

import argparse
import json
import sys
import uuid
from datetime import datetime, timezone
from pathlib import Path
from typing import Dict, Any, Optional
import base64

try:
    import requests
except ImportError:
    print("Error: requests library is required. Install with: pip install requests")
    sys.exit(1)

try:
    import yaml
    HAS_YAML = True
except ImportError:
    HAS_YAML = False


class RegistryClient:
    """Client for interacting with OCP Registry."""
    
    def __init__(self, base_url: str = "http://localhost:8000"):
        self.base_url = base_url.rstrip('/')
        
    def list_apis(self, category: Optional[str] = None, status: Optional[str] = None):
        """List APIs in the registry."""
        params = {}
        if category:
            params['category'] = category
        if status:
            params['status'] = status
            
        response = requests.get(f"{self.base_url}/api/v1/registry", params=params)
        response.raise_for_status()
        return response.json()
    
    def get_api(self, name: str):
        """Get specific API by name."""
        response = requests.get(f"{self.base_url}/api/v1/registry/{name}")
        response.raise_for_status()
        return response.json()
    
    def search_apis(self, query: str, page: int = 1, per_page: int = 20):
        """Search APIs."""
        params = {
            'q': query,
            'page': page,
            'per_page': per_page
        }
        response = requests.get(f"{self.base_url}/api/v1/search", params=params)
        response.raise_for_status()
        return response.json()
    
    def register_api(self, api_data: dict):
        """Register a new API."""
        response = requests.post(f"{self.base_url}/api/v1/registry", json=api_data)
        response.raise_for_status()
        return response.json()
    
    def validate_api(self, openapi_url: str, base_url: Optional[str] = None):
        """Validate an API specification."""
        data = {"openapi_url": openapi_url}
        if base_url:
            data["base_url"] = base_url
            
        response = requests.post(f"{self.base_url}/api/v1/validate", json=data)
        response.raise_for_status()
        return response.json()
    
    def get_categories(self):
        """Get all categories."""
        response = requests.get(f"{self.base_url}/api/v1/categories")
        response.raise_for_status()
        return response.json()
    
    def get_stats(self):
        """Get registry statistics."""
        response = requests.get(f"{self.base_url}/api/v1/stats")
        response.raise_for_status()
        return response.json()


class OCPContext:
    """Simple OCP context management."""
    
    def __init__(self, context_id: str = None, user: str = None, 
                 agent_type: str = "cli_agent", agent_goal: str = None):
        self.context_id = context_id or f"cli-{uuid.uuid4().hex[:8]}"
        self.timestamp = datetime.now(timezone.utc).isoformat()
        self.user = user
        self.agent_type = agent_type
        self.agent_goal = agent_goal
        self.session_history = []
    
    def to_dict(self) -> Dict[str, Any]:
        """Convert context to dictionary."""
        context = {
            "context_id": self.context_id,
            "timestamp": self.timestamp,
            "agent_type": self.agent_type,
            "user": self.user,
            "agent_goal": self.agent_goal,
            "session": {
                "history": self.session_history,
                "state": {}
            }
        }
        return {k: v for k, v in context.items() if v is not None}
    
    def to_headers(self) -> Dict[str, str]:
        """Convert context to OCP headers."""
        headers = {
            "OCP-Context-ID": self.context_id,
            "OCP-Agent-Type": self.agent_type,
        }
        
        if self.agent_goal:
            headers["OCP-Agent-Goal"] = self.agent_goal
        
        # Encode full context as base64
        context_json = json.dumps(self.to_dict())
        headers["OCP-Session"] = base64.b64encode(context_json.encode()).decode()
        
        return headers


class OCPCli:
    """OCP command line interface."""
    
    def __init__(self):
        self.context_file = Path.home() / ".ocp" / "context.json"
        self.context_file.parent.mkdir(exist_ok=True)
    
    def create_context(self, user: str = None, agent_type: str = "cli_agent", 
                      goal: str = None) -> OCPContext:
        """Create new OCP context."""
        context = OCPContext(
            user=user,
            agent_type=agent_type,
            agent_goal=goal
        )
        
        # Save to file
        with open(self.context_file, 'w') as f:
            json.dump(context.to_dict(), f, indent=2)
        
        print(f"Created context: {context.context_id}")
        return context
    
    def load_context(self) -> Optional[OCPContext]:
        """Load context from file."""
        if not self.context_file.exists():
            return None
        
        try:
            with open(self.context_file, 'r') as f:
                data = json.load(f)
            
            context = OCPContext(
                context_id=data.get("context_id"),
                user=data.get("user"),
                agent_type=data.get("agent_type", "cli_agent"),
                agent_goal=data.get("agent_goal")
            )
            context.session_history = data.get("session", {}).get("history", [])
            return context
        except Exception as e:
            print(f"Error loading context: {e}")
            return None
    
    def show_context(self, format_type: str = "json"):
        """Show current context."""
        context = self.load_context()
        if not context:
            print("No context found. Create one with: ocp context create")
            return
        
        data = context.to_dict()
        
        if format_type == "yaml" and HAS_YAML:
            print(yaml.dump(data, default_flow_style=False))
        else:
            print(json.dumps(data, indent=2))
    
    def make_call(self, method: str, url: str, context_id: str = None, 
                 data: str = None, auth: str = None):
        """Make OCP-enhanced API call."""
        context = self.load_context()
        if not context:
            print("No context found. Create one with: ocp context create")
            return
        
        # Prepare headers
        headers = context.to_headers()
        
        if auth:
            if auth.startswith(('Bearer ', 'token ', 'Basic ')):
                headers['Authorization'] = auth
            else:
                headers['Authorization'] = f'token {auth}'
        
        # Prepare request
        kwargs = {'headers': headers, 'timeout': 30}
        
        if data:
            try:
                kwargs['json'] = json.loads(data)
            except json.JSONDecodeError:
                kwargs['data'] = data
        
        try:
            response = requests.request(method, url, **kwargs)
            
            print(f"Status: {response.status_code} {response.reason}")
            print(f"Headers sent: {dict(headers)}")
            
            if response.headers.get('content-type', '').startswith('application/json'):
                try:
                    print("Response:")
                    print(json.dumps(response.json(), indent=2))
                except:
                    print(response.text)
            else:
                print("Response:")
                print(response.text[:1000] + "..." if len(response.text) > 1000 else response.text)
                
        except Exception as e:
            print(f"Error: {e}")
    
    def validate_context(self, file_path: str):
        """Validate context file."""
        try:
            with open(file_path, 'r') as f:
                data = json.load(f)
            
            required_fields = ["context_id", "agent_type"]
            missing = [field for field in required_fields if field not in data]
            
            if missing:
                print(f"Invalid context: missing fields {missing}")
                return False
            
            print("Context file is valid")
            return True
            
        except Exception as e:
            print(f"Error validating context: {e}")
            return False
    
    def test_api(self, base_url: str, spec_url: str = None, auth: str = None):
        """Test API with OCP context."""
        context = self.load_context()
        if not context:
            print("No context found. Create one with: ocp context create")
            return
        
        headers = context.to_headers()
        if auth:
            headers['Authorization'] = auth if auth.startswith(('Bearer ', 'token ', 'Basic ')) else f'token {auth}'
        
        # Test basic connectivity
        try:
            response = requests.get(base_url, headers=headers, timeout=10)
            print(f"API Test: {response.status_code} {response.reason}")
            
            if spec_url:
                print(f"Fetching OpenAPI spec from: {spec_url}")
                spec_response = requests.get(spec_url, timeout=10)
                if spec_response.ok:
                    print("OpenAPI spec retrieved successfully")
                    try:
                        spec_data = spec_response.json()
                        paths = spec_data.get('paths', {})
                        print(f"Available endpoints: {len(paths)}")
                    except:
                        print("Could not parse OpenAPI spec")
                else:
                    print(f"Could not fetch OpenAPI spec: {spec_response.status_code}")
            
        except Exception as e:
            print(f"API test failed: {e}")

    # Registry methods
    def _get_registry_client(self, url: str = None) -> RegistryClient:
        """Get registry client with default or specified URL."""
        return RegistryClient(url or "http://localhost:8000")
    
    def registry_list(self, category: str = None, status: str = None, registry_url: str = None):
        """List APIs in the registry."""
        try:
            client = self._get_registry_client(registry_url)
            result = client.list_apis(category=category, status=status)
            print(json.dumps(result, indent=2))
        except requests.exceptions.ConnectionError:
            print(json.dumps({"error": "Could not connect to registry"}, indent=2))
            sys.exit(1)
        except Exception as e:
            print(json.dumps({"error": str(e)}, indent=2))
            sys.exit(1)
    
    def registry_search(self, query: str, page: int = 1, per_page: int = 20, registry_url: str = None):
        """Search APIs in the registry."""
        try:
            client = self._get_registry_client(registry_url)
            result = client.search_apis(query, page=page, per_page=per_page)
            print(json.dumps(result, indent=2))
        except requests.exceptions.ConnectionError:
            print(json.dumps({"error": "Could not connect to registry"}, indent=2))
            sys.exit(1)
        except Exception as e:
            print(json.dumps({"error": str(e)}, indent=2))
            sys.exit(1)
    
    def registry_get(self, name: str, registry_url: str = None):
        """Get detailed information about an API."""
        try:
            client = self._get_registry_client(registry_url)
            result = client.get_api(name)
            print(json.dumps(result, indent=2, default=str))
        except requests.exceptions.HTTPError as e:
            if e.response.status_code == 404:
                print(json.dumps({"error": f"API '{name}' not found"}, indent=2))
            else:
                print(json.dumps({"error": f"HTTP {e.response.status_code}"}, indent=2))
            sys.exit(1)
        except requests.exceptions.ConnectionError:
            print(json.dumps({"error": "Could not connect to registry"}, indent=2))
            sys.exit(1)
        except Exception as e:
            print(json.dumps({"error": str(e)}, indent=2))
            sys.exit(1)
    
    def registry_register(self, file_path: str, registry_url: str = None):
        """Register an API from a JSON file."""
        try:
            with open(file_path, 'r') as f:
                api_data = json.load(f)
            
            client = self._get_registry_client(registry_url)
            result = client.register_api(api_data)
            print(json.dumps(result, indent=2, default=str))
        except FileNotFoundError:
            print(json.dumps({"error": f"File not found: {file_path}"}, indent=2))
            sys.exit(1)
        except json.JSONDecodeError:
            print(json.dumps({"error": f"Invalid JSON in file: {file_path}"}, indent=2))
            sys.exit(1)
        except requests.exceptions.HTTPError as e:
            if e.response.status_code == 400:
                print(json.dumps({"error": e.response.json().get('detail', 'Bad request')}, indent=2))
            else:
                print(json.dumps({"error": f"HTTP {e.response.status_code}"}, indent=2))
            sys.exit(1)
        except requests.exceptions.ConnectionError:
            print(json.dumps({"error": "Could not connect to registry"}, indent=2))
            sys.exit(1)
        except Exception as e:
            print(json.dumps({"error": str(e)}, indent=2))
            sys.exit(1)
    
    def registry_validate(self, openapi_url: str, base_url: str = None, registry_url: str = None):
        """Validate an API specification."""
        try:
            client = self._get_registry_client(registry_url)
            result = client.validate_api(openapi_url, base_url)
            print(json.dumps(result, indent=2))
        except requests.exceptions.ConnectionError:
            print(json.dumps({"error": "Could not connect to registry"}, indent=2))
            sys.exit(1)
        except Exception as e:
            print(json.dumps({"error": str(e)}, indent=2))
            sys.exit(1)
    
    def registry_categories(self, registry_url: str = None):
        """List available categories."""
        try:
            client = self._get_registry_client(registry_url)
            result = client.get_categories()
            print(json.dumps(result, indent=2))
        except requests.exceptions.ConnectionError:
            print(json.dumps({"error": "Could not connect to registry"}, indent=2))
            sys.exit(1)
        except Exception as e:
            print(json.dumps({"error": str(e)}, indent=2))
            sys.exit(1)
    
    def registry_stats(self, registry_url: str = None):
        """Show registry statistics."""
        try:
            client = self._get_registry_client(registry_url)
            result = client.get_stats()
            print(json.dumps(result, indent=2, default=str))
        except requests.exceptions.ConnectionError:
            print(json.dumps({"error": "Could not connect to registry"}, indent=2))
            sys.exit(1)
        except Exception as e:
            print(json.dumps({"error": str(e)}, indent=2))
            sys.exit(1)


def main():
    parser = argparse.ArgumentParser(description="OCP CLI - Context management and API testing")
    parser.add_argument('--version', action='version', version='ocp-cli 0.1.0')
    
    subparsers = parser.add_subparsers(dest='command', help='Available commands')
    
    # Context commands
    context_parser = subparsers.add_parser('context', help='Context management')
    context_subparsers = context_parser.add_subparsers(dest='context_action')
    
    create_parser = context_subparsers.add_parser('create', help='Create new context')
    create_parser.add_argument('--user', help='User identifier')
    create_parser.add_argument('--type', default='cli_agent', help='Agent type')
    create_parser.add_argument('--goal', help='Agent goal')
    
    show_parser = context_subparsers.add_parser('show', help='Show current context')
    show_parser.add_argument('--format', choices=['json', 'yaml'], default='json', help='Output format')
    
    # API call command
    call_parser = subparsers.add_parser('call', help='Make OCP-enhanced API call')
    call_parser.add_argument('method', help='HTTP method (GET, POST, etc.)')
    call_parser.add_argument('url', help='API URL')
    call_parser.add_argument('--context', help='Context ID')
    call_parser.add_argument('--data', help='Request data (JSON string)')
    call_parser.add_argument('--auth', help='Authorization header value')
    
    # Validation command
    validate_parser = subparsers.add_parser('validate', help='Validate files')
    validate_subparsers = validate_parser.add_subparsers(dest='validate_type')
    validate_context_parser = validate_subparsers.add_parser('context', help='Validate context file')
    validate_context_parser.add_argument('file', help='Context file to validate')
    
    # Test command
    test_parser = subparsers.add_parser('test', help='Test APIs')
    test_subparsers = test_parser.add_subparsers(dest='test_type')
    test_api_parser = test_subparsers.add_parser('api', help='Test API with OCP')
    test_api_parser.add_argument('url', help='API base URL')
    test_api_parser.add_argument('--spec', help='OpenAPI spec URL')
    test_api_parser.add_argument('--auth', help='Authorization header value')
    
    # Registry commands
    registry_parser = subparsers.add_parser('registry', help='OCP Registry operations')
    registry_parser.add_argument('--url', help='Registry URL (default: http://localhost:8000)')
    registry_subparsers = registry_parser.add_subparsers(dest='registry_action')
    
    # Registry list
    registry_list_parser = registry_subparsers.add_parser('list', help='List APIs in registry')
    registry_list_parser.add_argument('--category', help='Filter by category')
    registry_list_parser.add_argument('--status', help='Filter by status')
    
    # Registry search
    registry_search_parser = registry_subparsers.add_parser('search', help='Search APIs in registry')
    registry_search_parser.add_argument('query', help='Search query')
    registry_search_parser.add_argument('--page', type=int, default=1, help='Page number')
    registry_search_parser.add_argument('--per-page', type=int, default=20, help='Results per page')
    
    # Registry get
    registry_get_parser = registry_subparsers.add_parser('get', help='Get API details')
    registry_get_parser.add_argument('name', help='API name')
    
    # Registry register
    registry_register_parser = registry_subparsers.add_parser('register', help='Register API from JSON file')
    registry_register_parser.add_argument('file', help='JSON file with API registration data')
    
    # Registry validate
    registry_validate_parser = registry_subparsers.add_parser('validate', help='Validate API specification')
    registry_validate_parser.add_argument('openapi_url', help='OpenAPI specification URL')
    registry_validate_parser.add_argument('--base-url', help='API base URL')
    
    # Registry categories
    registry_categories_parser = registry_subparsers.add_parser('categories', help='List available categories')
    
    # Registry stats
    registry_stats_parser = registry_subparsers.add_parser('stats', help='Show registry statistics')
    
    args = parser.parse_args()
    
    if not args.command:
        parser.print_help()
        return
    
    cli = OCPCli()
    
    if args.command == 'context':
        if args.context_action == 'create':
            cli.create_context(args.user, args.type, args.goal)
        elif args.context_action == 'show':
            cli.show_context(args.format)
        else:
            context_parser.print_help()
    
    elif args.command == 'call':
        cli.make_call(args.method, args.url, args.context, args.data, args.auth)
    
    elif args.command == 'validate':
        if args.validate_type == 'context':
            cli.validate_context(args.file)
        else:
            validate_parser.print_help()
    
    elif args.command == 'test':
        if args.test_type == 'api':
            cli.test_api(args.url, args.spec, args.auth)
        else:
            test_parser.print_help()
    
    elif args.command == 'registry':
        registry_url = getattr(args, 'url', None)
        
        if args.registry_action == 'list':
            cli.registry_list(args.category, args.status, registry_url)
        elif args.registry_action == 'search':
            cli.registry_search(args.query, args.page, getattr(args, 'per_page', 20), registry_url)
        elif args.registry_action == 'get':
            cli.registry_get(args.name, registry_url)
        elif args.registry_action == 'register':
            cli.registry_register(args.file, registry_url)
        elif args.registry_action == 'validate':
            cli.registry_validate(args.openapi_url, getattr(args, 'base_url', None), registry_url)
        elif args.registry_action == 'categories':
            cli.registry_categories(registry_url)
        elif args.registry_action == 'stats':
            cli.registry_stats(registry_url)
        else:
            registry_parser.print_help()
    
    else:
        parser.print_help()


if __name__ == '__main__':
    main()