#!/usr/bin/env python3
"""
OCP CLI - Command line interface for Open Context Protocol

A CLI tool that uses the OCP Python library for context management, 
API testing, and validation. Provides zero-infrastructure OCP functionality.

Usage:
    ocp context create [--user USER] [--type TYPE] [--goal GOAL] [--workspace WORKSPACE]
    ocp context show
    ocp call METHOD URL [--data DATA] [--auth AUTH]
    ocp validate context FILE
    ocp test api URL [--spec SPEC_URL] [--auth AUTH]
    ocp registry list [--category CATEGORY] [--status STATUS]
    ocp registry search QUERY [--page PAGE] [--per-page COUNT]
    ocp registry get NAME
    ocp registry register FILE
    ocp registry validate OPENAPI_URL [--base-url BASE_URL]
    ocp registry categories
    ocp registry stats
    ocp --version
    ocp --help

Examples:
    # Create new context
    ocp context create --user alice --type ide_copilot --goal "debug tests" --workspace "payment-service"

    # Make OCP-enabled API call
    ocp call GET https://api.github.com/user --auth "token ghp_xxx"

    # Test API with OCP context
    ocp test api https://api.github.com --spec https://api.github.com/rest/openapi.json

    # Search for APIs in registry
    ocp registry search github

    # Get details about a specific API
    ocp registry get github

    # Register new API from JSON file
    ocp registry register my-api.json

    # Validate context file
    ocp validate context my-context.json
"""

import argparse
import json
import sys
from pathlib import Path
from typing import Optional

import requests
from ocp import AgentContext, OCPAgent, wrap_api, OCPRegistry, RegistryUnavailable, APINotFound


class OCPCli:
    """OCP command line interface using the OCP Python library."""
    
    def __init__(self):
        self.context_file = Path.home() / ".ocp" / "context.json"
        self.context_file.parent.mkdir(exist_ok=True)
    
    def create_context(self, user: str = None, agent_type: str = "cli_agent", 
                      goal: str = None, workspace: str = None) -> AgentContext:
        """Create new OCP context using the OCP library."""
        context = AgentContext(
            agent_type=agent_type,
            user=user,
            workspace=workspace
        )
        
        if goal:
            context.update_goal(goal)
        
        # Save to file
        with open(self.context_file, 'w') as f:
            json.dump(context.to_dict(), f, indent=2)
        
        print(f"Created context: {context.context_id}")
        return context
    
    def load_context(self) -> Optional[AgentContext]:
        """Load context from file."""
        if not self.context_file.exists():
            return None
        
        try:
            with open(self.context_file, 'r') as f:
                data = json.load(f)
            
            # Create context from saved data
            context = AgentContext(
                agent_type=data.get("agent_type", "cli_agent"),
                user=data.get("user"),
                workspace=data.get("workspace")
            )
            
            # Update fields from saved data
            context.context_id = data.get("context_id", context.context_id)
            context.current_goal = data.get("current_goal")
            context.context_summary = data.get("context_summary")
            context.history = data.get("history", [])
            
            return context
        except Exception as e:
            print(f"Error loading context: {e}")
            return None
    
    def show_context(self):
        """Show current context."""
        context = self.load_context()
        if not context:
            print("No context found. Create one with: ocp context create")
            return
        
        data = context.to_dict()
        print(json.dumps(data, indent=2))
    
    def make_call(self, method: str, url: str, data: str = None, auth: str = None):
        """Make OCP-enhanced API call using the OCP library."""
        context = self.load_context()
        if not context:
            print("No context found. Create one with: ocp context create")
            return
        
        # Create OCP-enhanced HTTP client
        try:
            from urllib.parse import urlparse
            parsed_url = urlparse(url)
            base_url = f"{parsed_url.scheme}://{parsed_url.netloc}"
            
            # Create context-aware client
            client = wrap_api(base_url, context)
            
            # Prepare request kwargs
            kwargs = {}
            if data:
                try:
                    kwargs['json'] = json.loads(data)
                except json.JSONDecodeError:
                    kwargs['data'] = data
            
            if auth:
                if not auth.startswith(('Bearer ', 'token ', 'Basic ')):
                    auth = f'token {auth}'
                kwargs['headers'] = kwargs.get('headers', {})
                kwargs['headers']['Authorization'] = auth
            
            # Make the request
            path = parsed_url.path + ('?' + parsed_url.query if parsed_url.query else '')
            response = client.request(method, path, **kwargs)
            
            print(f"Status: {response.status_code} {response.reason}")
            print(f"OCP Headers sent: {[h for h in response.request.headers if h.startswith('OCP-')]}")
            
            if response.headers.get('content-type', '').startswith('application/json'):
                try:
                    print("Response:")
                    print(json.dumps(response.json(), indent=2))
                except:
                    print(response.text)
            else:
                print("Response:")
                print(response.text[:1000] + "..." if len(response.text) > 1000 else response.text)
                
        except Exception as e:
            print(f"Error: {e}")
    
    def validate_context(self, file_path: str):
        """Validate context file."""
        try:
            with open(file_path, 'r') as f:
                data = json.load(f)
            
            # Try to create an AgentContext from the data to validate
            context = AgentContext(
                agent_type=data.get("agent_type", "unknown"),
                user=data.get("user"),
                workspace=data.get("workspace")
            )
            
            # Basic validation
            required_fields = ["context_id", "agent_type"]
            missing = [field for field in required_fields if field not in data]
            
            if missing:
                print(f"Invalid context: missing fields {missing}")
                return False
            
            print("Context file is valid")
            return True
            
        except Exception as e:
            print(f"Error validating context: {e}")
            return False
    
    def test_api(self, base_url: str, spec_url: str = None, auth: str = None):
        """Test API with OCP context using the OCP library."""
        context = self.load_context()
        if not context:
            print("No context found. Create one with: ocp context create")
            return
        
        try:
            # Create OCP agent for testing
            agent = OCPAgent(
                agent_type=context.agent_type,
                user=context.user,
                workspace=context.workspace,
                agent_goal=context.current_goal
            )
            
            # Test basic connectivity with OCP headers
            client = wrap_api(base_url, context)
            response = client.get("/")
            print(f"API Test: {response.status_code} {response.reason}")
            print(f"OCP headers sent: {[h for h in response.request.headers if h.startswith('OCP-')]}")
            
            if spec_url:
                print(f"Testing API discovery from: {spec_url}")
                try:
                    api_spec = agent.register_api("test_api", spec_url, base_url)
                    tools = agent.list_tools("test_api")
                    print(f"✅ OpenAPI spec loaded successfully")
                    print(f"   API: {api_spec.title} v{api_spec.version}")
                    print(f"   Tools discovered: {len(tools)}")
                    
                    # Show first few tools
                    for tool in tools[:3]:
                        print(f"   • {tool.name}: {tool.description[:50]}...")
                        
                except Exception as e:
                    print(f"❌ OpenAPI spec test failed: {e}")
            
        except Exception as e:
            print(f"API test failed: {e}")

    # Registry methods
    def _get_registry_client(self, url: str = None) -> OCPRegistry:
        """Get registry client with default or specified URL."""
        return OCPRegistry(url or "http://localhost:8000")
    
    def registry_list(self, category: str = None, status: str = None, registry_url: str = None):
        """List APIs in the registry."""
        try:
            client = self._get_registry_client(registry_url)
            result = client.list_apis()
            print(json.dumps(result, indent=2))
        except RegistryUnavailable:
            print(json.dumps({"error": "Could not connect to registry"}, indent=2))
            sys.exit(1)
        except Exception as e:
            print(json.dumps({"error": str(e)}, indent=2))
            sys.exit(1)
    
    def registry_search(self, query: str, page: int = 1, per_page: int = 20, registry_url: str = None):
        """Search APIs in the registry."""
        try:
            client = self._get_registry_client(registry_url)
            result = client.search_apis(query)
            print(json.dumps(result, indent=2))
        except RegistryUnavailable:
            print(json.dumps({"error": "Could not connect to registry"}, indent=2))
            sys.exit(1)
        except Exception as e:
            print(json.dumps({"error": str(e)}, indent=2))
            sys.exit(1)
    
    def registry_get(self, name: str, registry_url: str = None):
        """Get detailed information about an API."""
        try:
            client = self._get_registry_client(registry_url)
            api_spec = client.get_api_spec(name)
            # Convert OCPAPISpec to a serializable dict
            result = {
                "name": name,
                "title": api_spec.title,
                "version": api_spec.version,
                "description": api_spec.description,
                "base_url": api_spec.base_url,
                "tools_count": len(api_spec.tools),
                "tools": [
                    {
                        "name": tool.name,
                        "description": tool.description,
                        "method": tool.method,
                        "path": tool.path
                    }
                    for tool in api_spec.tools
                ]
            }
            print(json.dumps(result, indent=2, default=str))
        except APINotFound as e:
            error_msg = {"error": f"API '{name}' not found"}
            if e.suggestions:
                error_msg["suggestions"] = e.suggestions
            print(json.dumps(error_msg, indent=2))
            sys.exit(1)
        except RegistryUnavailable:
            print(json.dumps({"error": "Could not connect to registry"}, indent=2))
            sys.exit(1)
        except Exception as e:
            print(json.dumps({"error": str(e)}, indent=2))
            sys.exit(1)
    
    def registry_register(self, file_path: str, registry_url: str = None):
        """Register an API from a JSON file."""
        try:
            with open(file_path, 'r') as f:
                api_data = json.load(f)
            
            # Use direct HTTP request for registration (server-side operation)
            url = (registry_url or "http://localhost:8000").rstrip('/')
            response = requests.post(f"{url}/api/v1/registry", json=api_data)
            response.raise_for_status()
            result = response.json()
            print(json.dumps(result, indent=2, default=str))
        except FileNotFoundError:
            print(json.dumps({"error": f"File not found: {file_path}"}, indent=2))
            sys.exit(1)
        except json.JSONDecodeError:
            print(json.dumps({"error": f"Invalid JSON in file: {file_path}"}, indent=2))
            sys.exit(1)
        except requests.exceptions.HTTPError as e:
            if e.response.status_code == 400:
                try:
                    error_detail = e.response.json().get('detail', 'Bad request')
                except:
                    error_detail = 'Bad request'
                print(json.dumps({"error": error_detail}, indent=2))
            else:
                print(json.dumps({"error": f"HTTP {e.response.status_code}"}, indent=2))
            sys.exit(1)
        except requests.exceptions.ConnectionError:
            print(json.dumps({"error": "Could not connect to registry"}, indent=2))
            sys.exit(1)
        except Exception as e:
            print(json.dumps({"error": str(e)}, indent=2))
            sys.exit(1)
    
    def registry_validate(self, openapi_url: str, base_url: str = None, registry_url: str = None):
        """Validate an API specification."""
        try:
            # Use direct HTTP request for validation (server-side operation)
            url = (registry_url or "http://localhost:8000").rstrip('/')
            data = {"openapi_url": openapi_url}
            if base_url:
                data["base_url"] = base_url
            
            response = requests.post(f"{url}/api/v1/validate", json=data)
            response.raise_for_status()
            result = response.json()
            print(json.dumps(result, indent=2))
        except requests.exceptions.ConnectionError:
            print(json.dumps({"error": "Could not connect to registry"}, indent=2))
            sys.exit(1)
        except Exception as e:
            print(json.dumps({"error": str(e)}, indent=2))
            sys.exit(1)
    
    def registry_categories(self, registry_url: str = None):
        """List available categories."""
        try:
            # Use direct HTTP request for categories (server-side operation)
            url = (registry_url or "http://localhost:8000").rstrip('/')
            response = requests.get(f"{url}/api/v1/categories")
            response.raise_for_status()
            result = response.json()
            print(json.dumps(result, indent=2))
        except requests.exceptions.ConnectionError:
            print(json.dumps({"error": "Could not connect to registry"}, indent=2))
            sys.exit(1)
        except Exception as e:
            print(json.dumps({"error": str(e)}, indent=2))
            sys.exit(1)
    
    def registry_stats(self, registry_url: str = None):
        """Show registry statistics."""
        try:
            # Use direct HTTP request for stats (server-side operation)
            url = (registry_url or "http://localhost:8000").rstrip('/')
            response = requests.get(f"{url}/api/v1/stats")
            response.raise_for_status()
            result = response.json()
            print(json.dumps(result, indent=2, default=str))
        except requests.exceptions.ConnectionError:
            print(json.dumps({"error": "Could not connect to registry"}, indent=2))
            sys.exit(1)
        except Exception as e:
            print(json.dumps({"error": str(e)}, indent=2))
            sys.exit(1)


def main():
    parser = argparse.ArgumentParser(description="OCP CLI - Context management and API testing")
    parser.add_argument('--version', action='version', version='ocp-cli 0.2.0')
    
    subparsers = parser.add_subparsers(dest='command', help='Available commands')
    
    # Context commands
    context_parser = subparsers.add_parser('context', help='Context management')
    context_subparsers = context_parser.add_subparsers(dest='context_action')
    
    create_parser = context_subparsers.add_parser('create', help='Create new context')
    create_parser.add_argument('--user', help='User identifier')
    create_parser.add_argument('--type', default='cli_agent', help='Agent type')
    create_parser.add_argument('--goal', help='Agent goal')
    create_parser.add_argument('--workspace', help='Current workspace/project')
    
    show_parser = context_subparsers.add_parser('show', help='Show current context')
    
    # API call command
    call_parser = subparsers.add_parser('call', help='Make OCP-enhanced API call')
    call_parser.add_argument('method', help='HTTP method (GET, POST, etc.)')
    call_parser.add_argument('url', help='API URL')
    call_parser.add_argument('--data', help='Request data (JSON string)')
    call_parser.add_argument('--auth', help='Authorization header value')
    
    # Validation command
    validate_parser = subparsers.add_parser('validate', help='Validate files')
    validate_subparsers = validate_parser.add_subparsers(dest='validate_type')
    validate_context_parser = validate_subparsers.add_parser('context', help='Validate context file')
    validate_context_parser.add_argument('file', help='Context file to validate')
    
    # Test command
    test_parser = subparsers.add_parser('test', help='Test APIs')
    test_subparsers = test_parser.add_subparsers(dest='test_type')
    test_api_parser = test_subparsers.add_parser('api', help='Test API with OCP')
    test_api_parser.add_argument('url', help='API base URL')
    test_api_parser.add_argument('--spec', help='OpenAPI spec URL')
    test_api_parser.add_argument('--auth', help='Authorization header value')

    # Registry commands
    registry_parser = subparsers.add_parser('registry', help='OCP Registry operations')
    registry_parser.add_argument('--url', help='Registry URL (default: http://localhost:8000)')
    registry_subparsers = registry_parser.add_subparsers(dest='registry_action')
    
    # Registry list
    registry_list_parser = registry_subparsers.add_parser('list', help='List APIs in registry')
    registry_list_parser.add_argument('--category', help='Filter by category')
    registry_list_parser.add_argument('--status', help='Filter by status')
    
    # Registry search
    registry_search_parser = registry_subparsers.add_parser('search', help='Search APIs in registry')
    registry_search_parser.add_argument('query', help='Search query')
    registry_search_parser.add_argument('--page', type=int, default=1, help='Page number')
    registry_search_parser.add_argument('--per-page', type=int, default=20, help='Results per page')
    
    # Registry get
    registry_get_parser = registry_subparsers.add_parser('get', help='Get API details')
    registry_get_parser.add_argument('name', help='API name')
    
    # Registry register
    registry_register_parser = registry_subparsers.add_parser('register', help='Register API from JSON file')
    registry_register_parser.add_argument('file', help='JSON file with API registration data')
    
    # Registry validate
    registry_validate_parser = registry_subparsers.add_parser('validate', help='Validate API specification')
    registry_validate_parser.add_argument('openapi_url', help='OpenAPI specification URL')
    registry_validate_parser.add_argument('--base-url', help='API base URL')
    
    # Registry categories
    registry_categories_parser = registry_subparsers.add_parser('categories', help='List available categories')
    
    # Registry stats
    registry_stats_parser = registry_subparsers.add_parser('stats', help='Show registry statistics')
    
    args = parser.parse_args()
    
    if not args.command:
        parser.print_help()
        return
    
    cli = OCPCli()
    
    if args.command == 'context':
        if args.context_action == 'create':
            cli.create_context(args.user, args.type, args.goal, getattr(args, 'workspace', None))
        elif args.context_action == 'show':
            cli.show_context()
        else:
            context_parser.print_help()
    
    elif args.command == 'call':
        cli.make_call(args.method, args.url, args.data, args.auth)
    
    elif args.command == 'validate':
        if args.validate_type == 'context':
            cli.validate_context(args.file)
        else:
            validate_parser.print_help()
    
    elif args.command == 'test':
        if args.test_type == 'api':
            cli.test_api(args.url, args.spec, args.auth)
        else:
            test_parser.print_help()
    
    elif args.command == 'registry':
        registry_url = getattr(args, 'url', None)
        
        if args.registry_action == 'list':
            cli.registry_list(args.category, args.status, registry_url)
        elif args.registry_action == 'search':
            cli.registry_search(args.query, args.page, getattr(args, 'per_page', 20), registry_url)
        elif args.registry_action == 'get':
            cli.registry_get(args.name, registry_url)
        elif args.registry_action == 'register':
            cli.registry_register(args.file, registry_url)
        elif args.registry_action == 'validate':
            cli.registry_validate(args.openapi_url, getattr(args, 'base_url', None), registry_url)
        elif args.registry_action == 'categories':
            cli.registry_categories(registry_url)
        elif args.registry_action == 'stats':
            cli.registry_stats(registry_url)
        else:
            registry_parser.print_help()
    
    else:
        parser.print_help()


if __name__ == '__main__':
    main()