#!/usr/bin/env python3
"""
OCP CLI Tool - Command line interface for Open Context Protocol

Usage:
    ocp context create [--user USER] [--id ID]
    ocp context show [--format json|yaml]
    ocp call METHOD URL [--context CONTEXT_ID] [--data DATA]
    ocp github user [--token TOKEN] [--context CONTEXT_ID]
    ocp github repos [--token TOKEN] [--context CONTEXT_ID]
    ocp convert openapi URL [--output FILE]
    ocp validate context FILE
    ocp --help

Examples:
    # Create new context
    ocp context create --user alice

    # Make OCP-enabled API call
    ocp call GET https://api.github.com/user --context session-123

    # GitHub integration
    ocp github user --token ghp_xxx --context session-123
    ocp github repos --token ghp_xxx --context session-123

    # Convert OpenAPI spec to OCP-compatible
    ocp convert openapi https://api.github.com/openapi.json

    # Validate context file
    ocp validate context my-context.json
"""

import argparse
import json
import sys
from pathlib import Path
from typing import Dict, Any, Optional
import requests
import base64
from datetime import datetime
import uuid

# Import our GitHub OCP example
sys.path.append(str(Path(__file__).parent.parent / "examples" / "github-api"))
from github_ocp import GitHubOCP, OCPContext


class OCPCli:
    """Command line interface for OCP operations."""
    
    def __init__(self):
        self.contexts_dir = Path.home() / ".ocp" / "contexts"
        self.contexts_dir.mkdir(parents=True, exist_ok=True)
    
    def create_context(self, user: str = None, context_id: str = None) -> str:
        """Create a new OCP context."""
        if not context_id:
            context_id = f"ocp-{uuid.uuid4().hex[:8]}"
        
        context = OCPContext(context_id=context_id, user=user)
        
        # Save context to file
        context_file = self.contexts_dir / f"{context_id}.json"
        with open(context_file, 'w') as f:
            json.dump(context.context, f, indent=2)
        
        print(f"Created context: {context_id}")
        print(f"Saved to: {context_file}")
        return context_id
    
    def load_context(self, context_id: str) -> OCPContext:
        """Load context from file."""
        context_file = self.contexts_dir / f"{context_id}.json"
        if not context_file.exists():
            raise FileNotFoundError(f"Context not found: {context_id}")
        
        with open(context_file, 'r') as f:
            context_data = json.load(f)
        
        context = OCPContext()
        context.context = context_data
        return context
    
    def save_context(self, context: OCPContext):
        """Save context to file."""
        context_id = context.context["context_id"]
        context_file = self.contexts_dir / f"{context_id}.json"
        with open(context_file, 'w') as f:
            json.dump(context.context, f, indent=2)
    
    def show_context(self, context_id: str = None, format: str = "json"):
        """Show context information."""
        if context_id:
            context = self.load_context(context_id)
            data = context.context
        else:
            # Show all contexts
            contexts = []
            for file in self.contexts_dir.glob("*.json"):
                with open(file, 'r') as f:
                    contexts.append(json.load(f))
            data = {"contexts": contexts}
        
        if format == "yaml":
            import yaml
            print(yaml.dump(data, default_flow_style=False))
        else:
            print(json.dumps(data, indent=2))
    
    def make_call(self, method: str, url: str, context_id: str = None, data: str = None):
        """Make an OCP-enabled HTTP call."""
        headers = {"User-Agent": "OCP-CLI/1.0"}
        
        # Add context headers if provided
        if context_id:
            context = self.load_context(context_id)
            headers.update(context.to_headers())
        
        # Parse data if provided
        json_data = None
        if data:
            try:
                json_data = json.loads(data)
            except json.JSONDecodeError:
                print(f"Invalid JSON data: {data}")
                return
        
        # Make request
        response = requests.request(
            method=method.upper(),
            url=url,
            headers=headers,
            json=json_data
        )
        
        # Show response
        print(f"Status: {response.status_code}")
        print(f"Headers: {dict(response.headers)}")
        
        try:
            response_data = response.json()
            print(f"Body: {json.dumps(response_data, indent=2)}")
        except:
            print(f"Body: {response.text}")
        
        # Update context if successful
        if context_id and response.ok:
            context.add_interaction("http", f"{method.upper()} {url} -> {response.status_code}")
            self.save_context(context)
    
    def github_user(self, token: str, context_id: str = None):
        """Get GitHub user info with OCP context."""
        if context_id:
            context = self.load_context(context_id)
        else:
            context = OCPContext(user="github-user")
            context_id = context.context["context_id"]
            print(f"Created new context: {context_id}")
        
        github = GitHubOCP(token, context)
        user = github.get_user()
        
        print(json.dumps(user, indent=2))
        
        # Save updated context
        self.save_context(context)
        print(f"Context updated: {context_id}")
    
    def github_repos(self, token: str, context_id: str = None):
        """Get GitHub repos with OCP context."""
        if context_id:
            context = self.load_context(context_id)
        else:
            print("No context provided. Use 'ocp github user' first or provide --context")
            return
        
        github = GitHubOCP(token, context)
        repos = github.get_repos()
        
        print(f"Found {len(repos)} repositories:")
        for repo in repos[:10]:  # Show first 10
            print(f"  - {repo['name']} ({repo['stargazers_count']} stars)")
        
        # Save updated context
        self.save_context(context)
        print(f"Context updated: {context_id}")
    
    def convert_openapi(self, url: str, output: str = None):
        """Convert OpenAPI spec to OCP-compatible."""
        print(f"Fetching OpenAPI spec from: {url}")
        
        response = requests.get(url)
        if not response.ok:
            print(f"Failed to fetch OpenAPI spec: {response.status_code}")
            return
        
        try:
            spec = response.json()
        except json.JSONDecodeError:
            print("Invalid JSON in OpenAPI spec")
            return
        
        # Add OCP extensions
        if "info" not in spec:
            spec["info"] = {}
        
        spec["info"]["x-ocp-enabled"] = True
        spec["info"]["x-ocp-context-aware"] = True
        
        # Add example OCP extensions to paths
        if "paths" in spec:
            for path, operations in spec["paths"].items():
                for method, operation in operations.items():
                    if isinstance(operation, dict):
                        operation["x-ocp-context"] = {
                            "preserves": ["session_id", "user"],
                            "provides": [f"{method}_{path.replace('/', '_')}_result"]
                        }
        
        # Output result
        if output:
            with open(output, 'w') as f:
                json.dump(spec, f, indent=2)
            print(f"OCP-compatible spec saved to: {output}")
        else:
            print(json.dumps(spec, indent=2))
    
    def validate_context(self, file: str):
        """Validate context file against schema."""
        with open(file, 'r') as f:
            context = json.load(f)
        
        # Basic validation
        required_fields = ["context_id", "session"]
        missing = [field for field in required_fields if field not in context]
        
        if missing:
            print(f"❌ Invalid context: missing fields {missing}")
            return False
        
        print("✅ Context file is valid")
        return True


def main():
    parser = argparse.ArgumentParser(description="OCP CLI Tool")
    subparsers = parser.add_subparsers(dest="command", help="Available commands")
    
    # Context commands
    context_parser = subparsers.add_parser("context", help="Context management")
    context_subparsers = context_parser.add_subparsers(dest="context_action")
    
    create_parser = context_subparsers.add_parser("create", help="Create new context")
    create_parser.add_argument("--user", help="User identifier")
    create_parser.add_argument("--id", help="Context ID")
    
    show_parser = context_subparsers.add_parser("show", help="Show context")
    show_parser.add_argument("--format", choices=["json", "yaml"], default="json")
    show_parser.add_argument("context_id", nargs="?", help="Context ID to show")
    
    # HTTP call command
    call_parser = subparsers.add_parser("call", help="Make OCP HTTP call")
    call_parser.add_argument("method", help="HTTP method")
    call_parser.add_argument("url", help="URL to call")
    call_parser.add_argument("--context", help="Context ID")
    call_parser.add_argument("--data", help="JSON data to send")
    
    # GitHub commands
    github_parser = subparsers.add_parser("github", help="GitHub integration")
    github_subparsers = github_parser.add_subparsers(dest="github_action")
    
    github_user_parser = github_subparsers.add_parser("user", help="Get GitHub user")
    github_user_parser.add_argument("--token", required=True, help="GitHub token")
    github_user_parser.add_argument("--context", help="Context ID")
    
    github_repos_parser = github_subparsers.add_parser("repos", help="Get GitHub repos")
    github_repos_parser.add_argument("--token", required=True, help="GitHub token")
    github_repos_parser.add_argument("--context", help="Context ID")
    
    # Convert command
    convert_parser = subparsers.add_parser("convert", help="Convert specifications")
    convert_subparsers = convert_parser.add_subparsers(dest="convert_type")
    
    openapi_parser = convert_subparsers.add_parser("openapi", help="Convert OpenAPI spec")
    openapi_parser.add_argument("url", help="OpenAPI spec URL")
    openapi_parser.add_argument("--output", help="Output file")
    
    # Validate command
    validate_parser = subparsers.add_parser("validate", help="Validate files")
    validate_subparsers = validate_parser.add_subparsers(dest="validate_type")
    
    context_validate_parser = validate_subparsers.add_parser("context", help="Validate context")
    context_validate_parser.add_argument("file", help="Context file to validate")
    
    args = parser.parse_args()
    cli = OCPCli()
    
    try:
        if args.command == "context":
            if args.context_action == "create":
                cli.create_context(args.user, args.id)
            elif args.context_action == "show":
                cli.show_context(args.context_id, args.format)
        
        elif args.command == "call":
            cli.make_call(args.method, args.url, args.context, args.data)
        
        elif args.command == "github":
            if args.github_action == "user":
                cli.github_user(args.token, args.context)
            elif args.github_action == "repos":
                cli.github_repos(args.token, args.context)
        
        elif args.command == "convert":
            if args.convert_type == "openapi":
                cli.convert_openapi(args.url, args.output)
        
        elif args.command == "validate":
            if args.validate_type == "context":
                cli.validate_context(args.file)
        
        else:
            parser.print_help()
    
    except Exception as e:
        print(f"Error: {e}")
        sys.exit(1)


if __name__ == "__main__":
    main()